
#if defined(__APPLE__)
    #include <GLUT/glut.h>
#else
    #include <stdlib.h>
//    #include <GL/glew.h>
    #if defined(WIN32)
//        #include <GL/wglew.h>
    #endif
//    #include <GL/glut.h>
#endif

// XXXdyu-api
/*** XXX not required?
#include <version.h>

namespace OpenSubdiv {
    namespace OPENSUBDIV_VERSION {

        class Mutex {
            public:
                void Lock() {}
                void Unlock() {}
            };

        }
    using namespace OPENSUBDIV_VERSION;
    }
***/



#include <far/mesh.h>
#include <far/meshFactory.h>

#include <hbr/mesh.h>
#include <hbr/vertex.h>
#include <hbr/catmark.h>
#include <hbr/subdivision.h>

#include <osd/error.h>
#include <osd/vertex.h>

#include <osd/cpuDispatcher.h>
#include <osd/cpuComputeContext.h>
#include <osd/cpuComputeController.h>
#include <osd/cpuVertexBuffer.h>

#include "patchCommon.h"


// XXXdyu-api
typedef OpenSubdiv::HbrMesh<OpenSubdiv::OsdVertex>     OsdHbrMesh;
typedef OpenSubdiv::HbrVertex<OpenSubdiv::OsdVertex>   OsdHbrVertex;
typedef OpenSubdiv::HbrFace<OpenSubdiv::OsdVertex>     OsdHbrFace;
typedef OpenSubdiv::HbrHalfedge<OpenSubdiv::OsdVertex> OsdHbrHalfedge;

class MyPatch {
public:

    // Note that MyPatch retains a pointer to CVs and depends
    // on it remaining allocated.
    MyPatch(const unsigned int *CVs) {
        _cvs = CVs;
    }

    void Eval( float u, float v, vec3 *vertexBuffer, 
               vec3 *position,  vec3 *utangent, vec3 *vtangent) {
        EvalBSpline(u, v, vertexBuffer, _cvs,
                    *position, *utangent, *vtangent);
    }

    
    
    //  Packed patch control vertices
    //   0  1  2  3 
    //   4  5  6  7
    //   8  9 10 11
    //  12 13 14 15
    const unsigned int *_cvs; // 
};
 



static void
buildMesh(float *vertexData, int numVertices,
          int *indexData, int numIndices,
          int *faceData, int numFaces)
{
    // Create an OsdHbrMesh that represents the subdiv control hull
    // for the incoming mesh data
    static OpenSubdiv::HbrCatmarkSubdivision<OpenSubdiv::OsdVertex> _catmark;
    OsdHbrMesh *hbrMesh = new OsdHbrMesh(&_catmark);

    OpenSubdiv::OsdVertex v;
    for (int i = 0; i < numVertices; ++i) {
        hbrMesh->NewVertex(i, v);
    }

    std::vector<int> faceVerts;
    int faceDataOffset = 0;
    int ptexFaceIndex = 0;

    for (int fi = 0; fi<numFaces; ++fi) {
        int numFaceVerts = faceData[fi];

        faceVerts.resize(numFaceVerts);
        for (int fvi = 0; fvi < numFaceVerts; ++fvi) {
            faceVerts[fvi] = indexData[fvi + faceDataOffset];
        }

        OsdHbrFace *face = hbrMesh->NewFace(numFaceVerts, &faceVerts[0], 0);

        face->SetPtexIndex(ptexFaceIndex);
        ptexFaceIndex += (numFaceVerts == 4) ? 1 : numFaceVerts;

        faceDataOffset += numFaceVerts;
    }

    hbrMesh->Finish();


    // Do feature adaptive refinement on the subdiv to generate cubic
    // patches
    int level = 2;

    std::cout << "1\n";
    // true for adaptive
    OpenSubdiv::FarMeshFactory<OpenSubdiv::OsdVertex> meshFactory(
        hbrMesh, level, true);

    std::cout << "2\n";    
    // true for ptex data, false for fvar data
    OpenSubdiv::FarMesh<OpenSubdiv::OsdVertex> * farMesh =
        meshFactory.Create(true, false);

    std::cout << "3\n";        
    // We no longer need the control hull.  Note that the meshFactory.Create()
    // used hbrMesh
    delete hbrMesh;

    std::cout << "4\n";            

/*    
    // Iterate over the ptex coordinates 
    std::vector<int> const &
        ptexCoords = farMesh->GetPtexCoordinates(level);
    for (int i=0; i<ptexCoords.size(); i+=2) {
        const int *p = &ptexCoords[i];

        int faceIndex = p[0];

        int u = (p[1] >> 16) & 0xffff;
        int v = (p[1] & 0xffff);

        std::cerr << faceIndex << " " << u << " " << v;
        std::cerr << " --> face: " << faceIndex;
        std::cerr << " uvoffset: ("
                  << (float)u/(1<<level) << ", " << (float)v/(1<<level)
                  << ")";
        if (faceIndex < 0) {
            std::cerr << " non-quad coarse face";
        }
        std::cerr << "\n";
    }
*/


    const OpenSubdiv::FarPatchTables *patchTables = farMesh->GetPatchTables();
    
    if (not patchTables) {
        std::cout << "Oooops- patchTables not constructed\n";
        return;
    } else {
        std::cout << "Have some patchTables\n";
    }

    // Iterate over the patches generated by feature
    // adaptive refinement and create MyPatch objects.
    //
    
    const OpenSubdiv::FarTable<unsigned int> &ptable =
        patchTables->GetFullRegularPatches();

    std::vector<MyPatch> patches;
    
    // Iterate over all patches in this table.  Don't worry about markers here,
    // those would tell use what level of subdivision the patch was created on.
    // Just iterate over all patches, this is in blocks of 16 unsigned ints
    // per patch.
    const unsigned int *vertIndices = ptable[0];
    for (int i=0; i<ptable.GetSize(); i+=16) {
        std::cout << "patch at index " << i << "\n";

        // Create a patch object from the next block
        // of 16 control point indices stored in
        // the patch table.
        MyPatch patch(vertIndices + i);
        patches.push_back(patch);
    }

    

    std::cout << "Made " << patches.size() << " patches\n";


    // Now compute control point positions and shading data on the
    // refined surface.
    //
    // First, create OpenSubdiv compute objects 

    OpenSubdiv::OsdCpuComputeContext *osdComputeContext =
        OpenSubdiv::OsdCpuComputeContext::Create(farMesh);
    OpenSubdiv::OsdCpuComputeController osdComputeController;
    OpenSubdiv::OsdCpuVertexBuffer *osdVertexBuffer = 
        OpenSubdiv::OsdCpuVertexBuffer::Create(
            3 /* 3 floats for position*/ , farMesh->GetNumVertices());
    

    //
    // Send the animated coarse positions to the vertex buffer.
    //
    osdVertexBuffer->UpdateData(vertexData, numVertices);

    
    //
    // Dispatch subdivision work based on the coarse vertex buffer. At this 
    // point, the assigned dispatcher will queue up work, potentially in many
    // worker threads. If the subdivided data is required for further
    // processing a call to Synchronize() will allow you to block until
    // the worker threads complete.
    //
    osdComputeController.Refine(osdComputeContext, osdVertexBuffer);


    //
    // Is the call to Synchronize() needed here?
    //
    osdComputeController.Synchronize();
    
    float *points = osdVertexBuffer->BindCpuBuffer();

    for (int i=0; i< patches.size(); ++i) {
        for (float u=0; u<1.0; u+=0.1) {
            std::cout << "\t";            
            for (float v=0; v<1.0; v+=0.1) {
                vec3 position, utangent, vtangent;
                patches[i].Eval(u, v, (vec3*)points,
                                &position, &utangent, &vtangent);
                std::cout << "(" << position[0] << "," <<
                    position[1] << "," <<  position[2] << "), \n";
            }
            std::cout << "\n";
        }
        std::cout << "\n";
    }

    
    delete osdVertexBuffer;
}

static void
buildCube()
{
    float vertexData[] = {
        1.0f, 1.0f, 1.0f,
       -1.0f, 1.0f, 1.0f,
       -1.0f,-1.0f, 1.0f,
        1.0f,-1.0f, 1.0f,

       -1.0f,-1.0f,-1.0f,
       -1.0f, 1.0f,-1.0f,
        1.0f, 1.0f,-1.0f,
        1.0f,-1.0f,-1.0f,
    };
    int numVertices = (sizeof(vertexData) / sizeof(vertexData[0])) / 3;

    int indexData[] = {
        0, 1, 2, 3,
        4, 5, 6, 7,

        0, 3, 7, 6,
        4, 2, 1, 5,

        0, 6, 5, 1,
        4, 7, 3, 2,
    };
    int numIndices = sizeof(indexData) / sizeof(indexData[0]);
    
    int faceData[] = {
        4, 4, 4, 4, 4, 4,
    };
    int numFaces = sizeof(faceData) / sizeof(faceData[0]);

    buildMesh(vertexData, numVertices,
              indexData, numIndices,
              faceData, numFaces);
}

static void
buildTet()
{
    float vertexData[] = {
        -0.5, -0.78, 0.0,
         0.5, -0.78, 0.0,
         0.0,  0.78, 0.5,
         0.0,  0.78, 0.5,
    };
    int numVertices = (sizeof(vertexData) / sizeof(vertexData[0])) / 3;

    int indexData[] = {
        0, 2, 2,
        1, 3, 2,
        3, 0, 2,
        0, 3, 1,
    };
    int numIndices = sizeof(indexData) / sizeof(indexData[0]);

    int faceData[] = {
        3, 3, 3, 3,
    };
    int numFaces = sizeof(faceData) / sizeof(faceData[0]);
    
    buildMesh(vertexData, numVertices,
              indexData, numIndices,
              faceData, numFaces);
}

static void
buildPrism()
{
    float vertexData[] = {
        0.0, 0.0, 1.0,
        1.0, 0.0, 1.0,
        0.0, 1.0, 1.0,
        0.0, 0.0,-1.0,
        1.0, 0.0,-1.0,
        0.0, 1.0,-1.0,
    };
    int numVertices = (sizeof(vertexData) / sizeof(vertexData[0])) / 3;

    int indexData[] = {
        0, 1, 2,
        3, 5, 4,
        0, 3, 4, 1,
        0, 2, 5, 3,
        1, 4, 5, 2,
    };
    int numIndices = sizeof(indexData) / sizeof(indexData[0]);
    
    int faceData[] = {
        3, 3, 4, 4, 4,
    };
    int numFaces = sizeof(faceData) / sizeof(faceData[0]);

    buildMesh(vertexData, numVertices,
              indexData, numIndices,
              faceData, numFaces);
}

int vpWidth = 512, vpHeight = 512;

int
main(int argc, char **argv)
{
    std::cerr << "Cube\n";
//    buildCube();
    std::cerr << "\n";

    std::cerr << "Tet\n";
    buildTet();
    std::cerr << "\n";

    std::cerr << "Prism\n";
    buildPrism();
    std::cerr << "\n";
}
