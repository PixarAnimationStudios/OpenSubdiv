//
//   Copyright 2013 Pixar
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#ifndef FAR_PATCH_TABLES_FACTORY_H
#define FAR_PATCH_TABLES_FACTORY_H

#include "../version.h"

#include "../far/patchTables.h"

namespace OpenSubdiv {
namespace OPENSUBDIV_VERSION {

/// \brief A specialized factory for feature adaptive FarPatchTables
///
/// FarPatchTables contain the lists of vertices for each patch of an adaptive
/// mesh representation. This  specialized factory is a private helper for FarMeshFactory.
///
/// Separating the factory allows us to isolate Far data structures from Hbr dependencies.
///
template <class T> class FarPatchTablesFactory {

public:
    typedef std::vector<FarMesh<T> const *> FarMeshVector;
    typedef std::vector<FarPatchTables::PatchArrayVector> MultiPatchArrayVector;

    /// \brief Splices patch tables from multiple meshes.
    /// if non-null multPatchArrays is given, it returns subsets of patcharrays such that
    /// corresponding input meshes are separately expressed.
    /// Client code is responsible for deallocation.
    static FarPatchTables *Splice(FarMeshVector const &meshes,
                                  MultiPatchArrayVector *multiPatchArrays);

protected:
    template <class X, class Y> friend class FarMeshFactory;

    /// \brief Factory constructor for feature-adaptive meshes
    ///
    /// @param mesh        Hbr mesh to generate tables for
    ///
    /// @param nfaces      Number of faces in the mesh (cached for speed)
    ///
    /// @param remapTable  Vertex remapping table generated by FarMeshFactory
    ///
    FarPatchTablesFactory( HbrMesh<T> const * mesh, int nfaces, std::vector<int> const & remapTable );

    /// \brief Returns a feature-adaptive FarPatchTables instance
    ///
    /// @param maxvalence       Maximum vertex valence in the mesh
    ///
    /// @param numPtexFaces     Number of ptex faces
    ///
    /// @param fvarWidth        The width of the interleaved face-varying data
    ///
    /// @return                 A new instance of FarPatchTables
    ///
    FarPatchTables * Create(int maxvalence, int numPtexFaces=0, int fvarWidth=0 );


    typedef std::vector<std::vector< HbrFace<T> *> > FacesList;

    /// \brief Factory constructor for uniform meshes
    ///
    /// @param mesh             Hbr mesh to generate tables for
    ///
    /// @param flist            Vectors of pointers to HbrFace<T> for each level
    ///                         of subdivision
    ///
    /// @param remapTable       Vertex remapping table generated by FarMeshFactory
    ///
    /// @param firstLevel       First level of subdivision to use when building the
    ///                         PatchArrayVector (default -1 means only generate
    ///                         a single patch array for the highest level of
    ///                         subdivision)
    ///
    /// @param patchType        The type of patch to create: QUADS or TRIANGLES
    ///
    /// @param numPtexFaces     Number of ptex faces
    ///
    /// @param fvarWidth        The width of the interleaved face-varying data
    ///
    /// @return                 A new instance of FarPatchTables
    ///
    static FarPatchTables * Create( HbrMesh<T> const * mesh,
                                    FacesList const & flist,
                                    std::vector<int> const & remapTable,
                                    int firstLevel=-1,
                                    FarPatchTables::Type patchType=FarPatchTables::QUADS,
                                    int numPtexFaces=0,
                                    int fvarWidth=0 );

    typedef std::vector<unsigned int> VertexList;
    typedef std::map<unsigned int, unsigned int> VertexPermutation;
    typedef std::vector<int> SplitTable;

    /// \brief Remaps the vertices in the patch tables
    ///
    /// @param patchTables  the patch tables to modify
    ///
    /// @param vertexPermutation  permutation of the vertices
    ///
    static void RemapVertices( FarPatchTables * patchTables,
                               VertexPermutation const &vertexPermutation );

    /// \brief Shifts the vertices in a kernel batch
    ///
    /// @param patchTables  the patch tables to modify
    ///
    /// @param kernelBatch  the kernel batch
    ///
    /// @param numVertices  the number of vertices to shift
    ///
    static void ShiftVertices( FarPatchTables * patchTables,
                               FarKernelBatch const &kernelBatch,
                               int numVertices );

    /// \brief Splits patch control vertices that have been duplicated
    ///
    /// @param patchTables  the patch tables to modify
    ///
    /// @param splitTable  a table of offsets for each patch control vertex
    ///
    static void SplitVertices( FarPatchTables * patchTables,
                               SplitTable const &splitTable );

private:

    typedef FarPatchTables::Descriptor Descriptor;

    // Returns true if one of v's neighboring faces has vertices carrying the tag "wasTagged"
    static bool vertexHasTaggedNeighbors(HbrVertex<T> * v);

    // Returns the rotation for a boundary patch
    static unsigned char computeBoundaryPatchRotation( HbrFace<T> * f );

    // Returns the rotation for a corner patch
    static unsigned char computeCornerPatchRotation( HbrFace<T> * f );

    // Populates the face-varying data buffer 'coord' for the given face and
    // returns a pointer to the next entry in the table
    static float * computeFVarData(HbrFace<T> const *f, const int width, float *coord, bool isAdaptive);

    // Populates the patch parametrization descriptor 'coord' for the given face
    // returns a pointer to the next descriptor
    static FarPatchParam * computePatchParam(HbrFace<T> const *f, FarPatchParam *coord);

    // Populates an array of indices with the "one-ring" vertices for the given face
    unsigned int * getOneRing(HbrFace<T> const * f, int ringsize, unsigned int const * remap, unsigned int * result) const;

    // Populates the Gregory patch quad offsets table
    static void getQuadOffsets(HbrFace<T> const * f, unsigned int * result);

    // Iterates through the faces of an HbrMesh and tags the _adaptiveFlags on faces and vertices
    void tagAdaptivePatches( HbrMesh<T> const * mesh, int nfaces );

    // Hbr mesh accessor
    HbrMesh<T> const * getMesh() const { return _mesh; }

    // Number of faces in the Hbr mesh (cached for speed)
    int getNumFaces() const { return _nfaces; }

    // The number of patch arrays in the mesh
    int getNumPatchArrays() const;

    // The number of patches in the mesh
    static int getNumPatches( FarPatchTables::PatchArrayVector const & parrays );

    // Reserves tables based on the contents of the PatchArrayVector
    static void allocateTables( FarPatchTables * tables, int nlevels, int fvarwidth );

    // A convenience container for the different types of feature adaptive patches
    template<class TYPE> struct PatchTypes {

        static const int NUM_TRANSITIONS=6,
                         NUM_ROTATIONS=4;

        TYPE R[NUM_TRANSITIONS],                   // regular patch
             B[NUM_TRANSITIONS][NUM_ROTATIONS],    // boundary patch (4 rotations)
             C[NUM_TRANSITIONS][NUM_ROTATIONS],    // corner patch (4 rotations)
             G,                                    // gregory patch
             GB;                                   // gregory boundary patch

        PatchTypes() { memset(this, 0, sizeof(PatchTypes<TYPE>)); }

        // Returns the number of patches based on the patch type in the descriptor
        TYPE & getValue( FarPatchTables::Descriptor desc );

        // Counts the number of arrays required to store each type of patch used
        // in the primitive
        int getNumPatchArrays() const;
    };

    typedef PatchTypes<unsigned int*>   CVPointers;
    typedef PatchTypes<FarPatchParam *> ParamPointers;
    typedef PatchTypes<float *>         FVarPointers;
    typedef PatchTypes<int>             Counter;

    // Creates a PatchArray and appends it to a vector and keeps track of both
    // vertex and patch offsets
    void pushPatchArray( FarPatchTables::Descriptor desc,
                         FarPatchTables::PatchArrayVector & parray,
                         int npatches, int * voffset, int * poffset, int * qoffset );

    Counter _patchCtr;  // counters for full and transition patches

    HbrMesh<T> const * _mesh;

    // Reference to the vertex remapping table generated by FarMeshFactory
    std::vector<int> const &_remapTable;

    int _nfaces;
};

template <class T>
    template <class TYPE> TYPE &
FarPatchTablesFactory<T>::PatchTypes<TYPE>::getValue( FarPatchTables::Descriptor desc ) {

    switch (desc.GetType()) {
        case FarPatchTables::REGULAR          : return R[desc.GetPattern()];
        case FarPatchTables::BOUNDARY         : return B[desc.GetPattern()][desc.GetRotation()];
        case FarPatchTables::CORNER           : return C[desc.GetPattern()][desc.GetRotation()];
        case FarPatchTables::GREGORY          : return G;
        case FarPatchTables::GREGORY_BOUNDARY : return GB;
        default : assert(0);
    }
    // can't be reached (suppress compiler warning)
    return R[0];
}

template <class T>
    template <class TYPE> int
FarPatchTablesFactory<T>::PatchTypes<TYPE>::getNumPatchArrays() const {

    int result=0;

    for (int i=0; i<6; ++i) {

        if (R[i]) ++result;

        for (int j=0; j<4; ++j) {
            if (B[i][j]) ++result;
            if (C[i][j]) ++result;

        }
    }

    if (G) ++result;
    if (GB) ++result;

    return result;
}

// True if the surrounding faces are "tagged" (unsupported feature : watertight
// critical patches)
template <class T> bool
FarPatchTablesFactory<T>::vertexHasTaggedNeighbors(HbrVertex<T> * v) {

    assert(v);

    HbrHalfedge<T> * start = v->GetIncidentEdge(),
                   * next=start;
    do {
        HbrFace<T> * right = next->GetRightFace(),
                   * left = next->GetLeftFace();

        if (right and (not right->hasTaggedVertices()))
            return true;

        if (left and (not left->hasTaggedVertices()))
            return true;

        next = v->GetNextEdge(next);

    } while (next and next!=start);
    return false;
}

// Returns a rotation index for boundary patches (range [0-3])
template <class T> unsigned char
FarPatchTablesFactory<T>::computeBoundaryPatchRotation( HbrFace<T> * f ) {
    unsigned char rot=0;
    for (unsigned char i=0; i<4;++i) {
        if (f->GetVertex(i)->OnBoundary() and
            f->GetVertex((i+1)%4)->OnBoundary())
            break;
        ++rot;
    }
    return rot;
}

// Returns a rotation index for corner patches (range [0-3])
template <class T> unsigned char
FarPatchTablesFactory<T>::computeCornerPatchRotation( HbrFace<T> * f ) {
    unsigned char rot=0;
    for (unsigned char i=0; i<4; ++i) {
        if (not f->GetVertex((i+3)%4)->OnBoundary())
            break;
        ++rot;
    }
    return rot;
}

// Reserves tables based on the contents of the PatchArrayVector
template <class T> void
FarPatchTablesFactory<T>::allocateTables( FarPatchTables * tables, int nlevels, int fvarwidth ) {

    int nverts = tables->GetNumControlVertices(),
        npatches = getNumPatches(tables->GetPatchArrayVector());

    if (nverts==0 or npatches==0)
        return;

    tables->_patches.resize( nverts );

    tables->_paramTable.resize( npatches );

    if (fvarwidth>0) {
        FarPatchTables::PatchArrayVector const & parrays = tables->GetPatchArrayVector();
        int nfvarverts = 0;
        for (int i=0; i<(int)parrays.size(); ++i) {
            nfvarverts += parrays[i].GetNumPatches() *
                          (parrays[i].GetDescriptor().GetType() == FarPatchTables::TRIANGLES ? 3 : 4);
        }

        tables->_fvarData._data.resize( nfvarverts * fvarwidth );

        if (nlevels >1) {
            tables->_fvarData._offsets.resize( nlevels );
        }
    }
}

// Uniform mesh factory (static function because it requires no cached state)
template <class T> FarPatchTables *
FarPatchTablesFactory<T>::Create( HbrMesh<T> const * mesh, FacesList const & flist, std::vector<int> const & remapTable, int firstLevel, FarPatchTables::Type patchType, int numPtexFaces, int fvarwidth ) {

    assert(patchType == FarPatchTables::QUADS || patchType == FarPatchTables::TRIANGLES);

    if (flist.size()<2)
        return 0;

    FarPatchTables * result = new FarPatchTables(0);

    bool isLoop = FarMeshFactory<T,T>::isLoop(mesh);
    if (isLoop)
        patchType = FarPatchTables::TRIANGLES;

    bool triangulateQuads = !isLoop && patchType == FarPatchTables::TRIANGLES;

    int nverts = patchType == FarPatchTables::TRIANGLES ? 3 : 4;

    int firstArray = firstLevel > -1 ? firstLevel : (int)flist.size()-1,
        nlevels = (int)flist.size()-firstArray;

    // Populate the patch array descriptors

    FarPatchTables::PatchArrayVector & parray = result->_patchArrays;
    parray.reserve( (int)flist.size() - firstArray );

    Descriptor desc( patchType, FarPatchTables::NON_TRANSITION, 0 );

    for (int i=1, poffset=0, voffset=0; i<(int)flist.size(); ++i) {

        int npatches = (int)flist[i].size();
        if (triangulateQuads)
            npatches *= 2;

        if (i>=firstArray) {
            parray.push_back( FarPatchTables::PatchArray(desc, voffset, poffset, npatches, 0 ) );

            voffset += npatches * nverts;
            poffset += npatches;
        }
    }

    result->_fvarData._fvarWidth = fvarwidth;
    result->_numPtexFaces = numPtexFaces;

    // Populate the patch / param / fvar tables

    allocateTables( result, nlevels, fvarwidth );

    unsigned int  * iptr = &result->_patches[0];
    FarPatchParam * pptr = &result->_paramTable[0];
    float         * fptr = fvarwidth>0 ? &result->_fvarData._data[0] : 0;

    for (int level=firstArray, fvarOffset=0; level<(int)flist.size(); ++level) {

        for (int i=0; i<(int)flist[level].size(); ++i) {
            HbrFace<T> * f = flist[level][i];
            assert( f and (f->GetNumVertices() == (isLoop ? 3 : 4)));

            for (int j=0; j<f->GetNumVertices(); ++j) {
                *iptr++ = remapTable[f->GetVertex(j)->GetID()];
            }

            pptr = computePatchParam(f, pptr);

            if (fvarwidth>0)
                fptr = computeFVarData(f, fvarwidth, fptr, /*isAdaptive=*/false);

            if (triangulateQuads) {
                // Triangulate the quadrilateral: {v0,v1,v2,v3} -> {v0,v1,v2},{v3,v0,v2}.
                *iptr = *(iptr - 4); // copy v0 index
                ++iptr;
                *iptr = *(iptr - 3); // copy v2 index
                ++iptr;

                *pptr = *(pptr - 1); // copy first patch param
                ++pptr;

                for (int j = 0; j < fvarwidth; ++j, ++fptr) {
                    *fptr = *(fptr - 4 * fvarwidth); // copy v0 fvar data
                }
                for (int j = 0; j < fvarwidth; ++j, ++fptr) {
                    *fptr = *(fptr - 3 * fvarwidth); // copy v2 fvar data
                }
            }
        }

        if (fvarwidth>0 and (not result->_fvarData._offsets.empty())) {
            result->_fvarData._offsets[level-firstArray] = (fvarOffset+=(int)flist[level].size()*nverts*fvarwidth);
        }
    }

    return result;
}

// PatchTables Factory
template <class T>
FarPatchTablesFactory<T>::FarPatchTablesFactory( HbrMesh<T> const * mesh, int nfaces,  std::vector<int> const & remapTable ) :
    _mesh(mesh),
    _remapTable(remapTable),
    _nfaces(nfaces)
{
    assert(mesh and nfaces>0);

    // First pass : identify transition / watertight-critical
    for (int i=0; i<nfaces; ++i) {

        HbrFace<T> * f = mesh->GetFace(i);

        if (f->_adaptiveFlags.isTagged and (not f->IsHole())) {
            HbrVertex<T> * v = f->Subdivide();
            assert(v);
            v->_adaptiveFlags.wasTagged=true;
        }

        int nv = f->GetNumVertices();
        for (int j=0; j<nv; ++j) {

            if (f->IsCoarse())
                f->GetVertex(j)->_adaptiveFlags.wasTagged=true;

            HbrHalfedge<T> * e = f->GetEdge(j);

            // Flag transition edge that require a triangulated transition
            if (f->_adaptiveFlags.isTagged) {
                e->_adaptiveFlags.isTriangleHead=true;

                // Both half-edges need to be tagged if an opposite exists
                if (e->GetOpposite())
                    e->GetOpposite()->_adaptiveFlags.isTriangleHead=true;
            }

            HbrFace<T> * left = e->GetLeftFace(),
                       * right = e->GetRightFace();

            if (not (left and right))
                continue;

            // a tagged edge w/ no children is inside a hole
            if (e->HasChild() and (left->_adaptiveFlags.isTagged ^ right->_adaptiveFlags.isTagged)) {

                e->_adaptiveFlags.isTransition = true;

                HbrVertex<T> * child = e->Subdivide();
                assert(child);

                // These edges will require extra rows of CVs to maintain water-tightness
                // Note : vertices inside holes have no children
                if (e->GetOrgVertex()->HasChild()) {
                    HbrHalfedge<T> * org = child->GetEdge(e->GetOrgVertex()->Subdivide());
                    if (org)
                        org->_adaptiveFlags.isWatertightCritical=true;
                }

                if (e->GetDestVertex()->HasChild()) {
                    HbrHalfedge<T> * dst = child->GetEdge(e->GetDestVertex()->Subdivide());
                    if (dst)
                        dst->_adaptiveFlags.isWatertightCritical=true;
                }
            }
        }
    }

    // Second pass : count boundaries / identify transition constellation
    for (int i=0; i<nfaces; ++i) {

        HbrFace<T> * f = mesh->GetFace(i);

        if (mesh->GetSubdivision()->FaceIsExtraordinary(mesh,f))
            continue;

        if (f->IsHole())
            continue;

        bool isTagged=0, wasTagged=0, isConnected=0, isWatertightCritical=0, isExtraordinary=0;
        int  triangleHeads=0, boundaryVerts=0;

        int nv = f->GetNumVertices();
        for (int j=0; j<nv; ++j) {
            HbrVertex<T> * v = f->GetVertex(j);

            if (v->OnBoundary()) {
                boundaryVerts++;

                // Boundary vertices with valence higher than 3 aren't Full Boundary
                // patches, they are Gregory Boundary patches.
                if (v->IsSingular() or v->GetValence()>3)
                    isExtraordinary=true;

            } else if (v->IsExtraordinary())
                isExtraordinary=true;

            if (f->GetParent() and (not isWatertightCritical))
                isWatertightCritical = vertexHasTaggedNeighbors(v);

            if (v->_adaptiveFlags.isTagged)
                isTagged=1;

            if (v->_adaptiveFlags.wasTagged)
                wasTagged=1;

            // Count the number of triangle heads to find which transition
            // pattern to use.
            HbrHalfedge<T> * e = f->GetEdge(j);
            if (e->_adaptiveFlags.isTriangleHead) {

                ++triangleHeads;
                if (f->GetEdge((j+1)%4)->_adaptiveFlags.isTriangleHead)
                    isConnected=true;
            }
        }

        f->_adaptiveFlags.bverts=boundaryVerts;
        f->_adaptiveFlags.isCritical=isWatertightCritical;

        // Regular Boundary Patch
        if (wasTagged)
            // XXXX manuelk - need to implement end patches
            f->_adaptiveFlags.patchType = HbrFace<T>::kEnd;

        if (f->_adaptiveFlags.isTagged)
            continue;

        assert(f->_adaptiveFlags.rots==0 and nv==4);

        if (not isTagged and wasTagged) {

            if (triangleHeads==0) {

                 if (not isExtraordinary and boundaryVerts!=1) {

                    // Full Patches
                    f->_adaptiveFlags.patchType = HbrFace<T>::kFull;

                    switch (boundaryVerts) {

                        case 0 : {   // Regular patch
                                     _patchCtr.R[FarPatchTables::NON_TRANSITION]++;
                                 } break;

                        case 2 : {   // Boundary patch
                                     f->_adaptiveFlags.rots=computeBoundaryPatchRotation(f);
                                     _patchCtr.B[FarPatchTables::NON_TRANSITION][0]++;
                                 } break;

                        case 3 : {   // Corner patch
                                     f->_adaptiveFlags.rots=computeCornerPatchRotation(f);
                                     _patchCtr.C[FarPatchTables::NON_TRANSITION][0]++;
                                 } break;

                        default : break;
                    }
                } else {

                    // Default to Gregory Patch
                    f->_adaptiveFlags.patchType = HbrFace<T>::kGregory;

                    switch (boundaryVerts) {

                        case 0 : {   // Regular Gregory patch
                                     _patchCtr.G++;
                                 } break;


                        default : { // Boundary Gregory patch
                                     _patchCtr.GB++;
                                  } break;
                    }
                }

            } else {

                // Transition Patch

                // Resolve transition constellation : 5 types (see p.5 fig. 7)
                switch (triangleHeads) {

                    case 1 : {   for (unsigned char j=0; j<4; ++j) {
                                     if (f->GetEdge(j)->IsTriangleHead())
                                         break;
                                     f->_adaptiveFlags.rots++;
                                 }
                                 f->_adaptiveFlags.transitionType = HbrFace<T>::kTransition0;
                            } break;

                    case 2 : {   for (unsigned char j=0; j<4; ++j) {
                                     if (isConnected) {
                                         if (f->GetEdge(j)->IsTriangleHead() and
                                             f->GetEdge((j+3)%4)->IsTriangleHead())
                                             break;
                                     } else {
                                         if (f->GetEdge(j)->IsTriangleHead())
                                             break;
                                     }
                                     f->_adaptiveFlags.rots++;
                                 }

                                 if (isConnected)
                                    f->_adaptiveFlags.transitionType = HbrFace<T>::kTransition1;
                                 else
                                    f->_adaptiveFlags.transitionType = HbrFace<T>::kTransition4;
                             } break;

                    case 3 : {   for (unsigned char j=0; j<4; ++j) {
                                     if (not f->GetEdge(j)->IsTriangleHead())
                                         break;
                                     f->_adaptiveFlags.rots++;
                                 }
                                 f->_adaptiveFlags.transitionType = HbrFace<T>::kTransition2;
                             } break;

                    case 4 : f->_adaptiveFlags.transitionType = HbrFace<T>::kTransition3;
                             break;

                    default: break;
                }

                int pattern = f->_adaptiveFlags.transitionType;
                assert(pattern>=0);

                // Correct rotations for corners & boundaries
                if (not isExtraordinary and boundaryVerts!=1) {

                    switch (boundaryVerts) {

                        case 0 : {   // regular patch
                                     _patchCtr.R[pattern+1]++;
                                 } break;

                        case 2 : {   // boundary patch
                                     unsigned char rot=computeBoundaryPatchRotation(f);

                                     f->_adaptiveFlags.brots=(4-f->_adaptiveFlags.rots+rot)%4;

                                     f->_adaptiveFlags.rots=rot; // override the transition rotation

                                     _patchCtr.B[pattern+1][f->_adaptiveFlags.brots]++;
                                 } break;

                        case 3 : {   // corner patch
                                     unsigned char rot=computeCornerPatchRotation(f);

                                     f->_adaptiveFlags.brots=(4-f->_adaptiveFlags.rots+rot)%4;

                                     f->_adaptiveFlags.rots=rot; // override the transition rotation

                                     _patchCtr.C[pattern+1][f->_adaptiveFlags.brots]++;
                                 } break;

                        default : assert(0); break;
                    }
                } else {
                    // Use Gregory Patch transition ?
                }
            }
        }
    }
}

template <class T> int
FarPatchTablesFactory<T>::getNumPatchArrays() const {

    return _patchCtr.getNumPatchArrays();
}

template <class T> int
FarPatchTablesFactory<T>::getNumPatches( FarPatchTables::PatchArrayVector const & parrays ) {

    int result=0;
    for (int i=0; i<(int)parrays.size(); ++i) {
        result += parrays[i].GetNumPatches();
    }

    return result;
}

template <class T> void
FarPatchTablesFactory<T>::pushPatchArray( FarPatchTables::Descriptor desc,
                                          FarPatchTables::PatchArrayVector & parray,
                                          int npatches, int * voffset, int * poffset, int * qoffset ) {

    if (npatches>0) {
        parray.push_back( FarPatchTables::PatchArray(desc, *voffset, *poffset, npatches, *qoffset) );

        *voffset += npatches * desc.GetNumControlVertices();
        *poffset += npatches;
        *qoffset += (desc.GetType() == FarPatchTables::GREGORY) ? npatches * desc.GetNumControlVertices() : 0;
    }
}

// Feature adaptive mesh factory
template <class T> FarPatchTables *
FarPatchTablesFactory<T>::Create(int maxvalence, int numPtexFaces, int fvarwidth ) {

    static const unsigned int remapRegular        [16] = {5,6,10,9,4,0,1,2,3,7,11,15,14,13,12,8};
    static const unsigned int remapRegularBoundary[12] = {1,2,6,5,0,3,7,11,10,9,8,4};
    static const unsigned int remapRegularCorner  [ 9] = {1,2,5,4,0,8,7,6,3};

    assert(getMesh() and getNumFaces()>0);

    FarPatchTables * result = new FarPatchTables(maxvalence);

    // Populate the patch array descriptors
    FarPatchTables::PatchArrayVector & parray = result->_patchArrays;
    parray.reserve( getNumPatchArrays() );

    int voffset=0, poffset=0, qoffset=0;


    for (Descriptor::iterator it=Descriptor::begin(Descriptor::FEATURE_ADAPTIVE_CATMARK);
        it!=Descriptor::end(); ++it) {

        pushPatchArray( *it, parray, _patchCtr.getValue(*it), &voffset, &poffset, &qoffset );
    }

    result->_fvarData._fvarWidth = fvarwidth;
    result->_numPtexFaces = numPtexFaces;

    // Allocate various tables
    allocateTables( result, 0, fvarwidth );

    if ((_patchCtr.G > 0) or (_patchCtr.GB > 0)) { // Quad-offsets tables (for Gregory patches)
        result->_quadOffsetTable.resize( _patchCtr.G*4 + _patchCtr.GB*4 );
    }

    // Setup convenience pointers at the beginning of each patch array for each
    // table (patches, ptex, fvar)
    CVPointers    iptrs;
    ParamPointers pptrs;
    FVarPointers  fptrs;

    for (Descriptor::iterator it=Descriptor::begin(Descriptor::FEATURE_ADAPTIVE_CATMARK);
        it!=Descriptor::end(); ++it) {

        FarPatchTables::PatchArray * pa = result->findPatchArray(*it);

        if (not pa)
            continue;

        iptrs.getValue( *it ) = &result->_patches[pa->GetVertIndex()];
        pptrs.getValue( *it ) = &result->_paramTable[pa->GetPatchIndex()];

        if (fvarwidth>0)
            fptrs.getValue( *it ) = &result->_fvarData._data[pa->GetPatchIndex() * 4 * fvarwidth];
    }

    FarPatchTables::QuadOffsetTable::value_type *quad_G_C0_P = _patchCtr.G>0 ? &result->_quadOffsetTable[0] : 0;
    FarPatchTables::QuadOffsetTable::value_type *quad_G_C1_P = _patchCtr.GB>0 ? &result->_quadOffsetTable[_patchCtr.G*4] : 0;

    // Populate patch index tables with vertex indices
    for (int i=0; i<getNumFaces(); ++i) {

        HbrFace<T> * f = getMesh()->GetFace(i);

        if (not f->isTransitionPatch() ) {

            // Full / End patches

            if (f->_adaptiveFlags.patchType==HbrFace<T>::kFull) {
                if (not f->_adaptiveFlags.isExtraordinary and f->_adaptiveFlags.bverts!=1) {

                    int pattern = FarPatchTables::NON_TRANSITION,
                        rot = 0;

                    switch (f->_adaptiveFlags.bverts) {
                        case 0 : {   // Regular Patch (16 CVs)
                                     iptrs.R[pattern] = getOneRing(f, 16, remapRegular, iptrs.R[0]);
                                     pptrs.R[pattern] = computePatchParam(f, pptrs.R[0]);
                                     fptrs.R[pattern] = computeFVarData(f, fvarwidth, fptrs.R[0], /*isAdaptive=*/true);
                                 } break;

                        case 2 : {   // Boundary Patch (12 CVs)
                                     f->_adaptiveFlags.brots = (f->_adaptiveFlags.rots+1)%4;
                                     iptrs.B[pattern][rot] = getOneRing(f, 12, remapRegularBoundary, iptrs.B[0][0]);
                                     pptrs.B[pattern][rot] = computePatchParam(f, pptrs.B[0][0]);
                                     fptrs.B[pattern][rot] = computeFVarData(f, fvarwidth, fptrs.B[0][0], /*isAdaptive=*/true);
                                 } break;

                        case 3 : {   // Corner Patch (9 CVs)
                                     f->_adaptiveFlags.brots = (f->_adaptiveFlags.rots+1)%4;
                                     iptrs.C[pattern][rot] = getOneRing(f, 9, remapRegularCorner, iptrs.C[0][0]);
                                     pptrs.C[pattern][rot] = computePatchParam(f, pptrs.C[0][0]);
                                     fptrs.C[pattern][rot] = computeFVarData(f, fvarwidth, fptrs.C[0][0], /*isAdaptive=*/true);
                                 } break;

                        default : assert(0);
                    }
                }
            } else if (f->_adaptiveFlags.patchType==HbrFace<T>::kGregory) {

                if (f->_adaptiveFlags.bverts==0) {

                    // Gregory Regular Patch (4 CVs + quad-offsets / valence tables)
                    for (int j=0; j<4; ++j)
                        iptrs.G[j] = _remapTable[f->GetVertex(j)->GetID()];
                    iptrs.G+=4;
                    getQuadOffsets(f, quad_G_C0_P);
                    quad_G_C0_P += 4;
                    pptrs.G = computePatchParam(f, pptrs.G);
                    fptrs.G = computeFVarData(f, fvarwidth, fptrs.G, /*isAdaptive=*/true);
                } else {

                    // Gregory Boundary Patch (4 CVs + quad-offsets / valence tables)
                    for (int j=0; j<4; ++j)
                        iptrs.GB[j] = _remapTable[f->GetVertex(j)->GetID()];
                    iptrs.GB+=4;
                    getQuadOffsets(f, quad_G_C1_P);
                    quad_G_C1_P += 4;
                    pptrs.GB = computePatchParam(f, pptrs.GB);
                    fptrs.GB = computeFVarData(f, fvarwidth, fptrs.GB, /*isAdaptive=*/true);
                }
            } else {
                // XXXX manuelk - end patches here
            }
        } else {

            // Transition patches

            int pattern = f->_adaptiveFlags.transitionType;
            assert( pattern>=HbrFace<T>::kTransition0 and pattern<=HbrFace<T>::kTransition4 );
            ++pattern;  // TransitionPattern begin with NON_TRANSITION

            if (not f->_adaptiveFlags.isExtraordinary and f->_adaptiveFlags.bverts!=1) {

                switch (f->_adaptiveFlags.bverts) {
                    case 0 : {   // Regular Transition Patch (16 CVs)
                                 iptrs.R[pattern] = getOneRing(f, 16, remapRegular, iptrs.R[pattern]);
                                 pptrs.R[pattern] = computePatchParam(f, pptrs.R[pattern]);
                                 fptrs.R[pattern] = computeFVarData(f, fvarwidth, fptrs.R[pattern], /*isAdaptive=*/true);
                             } break;

                    case 2 : {   // Boundary Transition Patch (12 CVs)
                                 unsigned rot = f->_adaptiveFlags.brots;
                                 iptrs.B[pattern][rot] = getOneRing(f, 12, remapRegularBoundary, iptrs.B[pattern][rot]);
                                 pptrs.B[pattern][rot] = computePatchParam(f, pptrs.B[pattern][rot]);
                                 fptrs.B[pattern][rot] = computeFVarData(f, fvarwidth, fptrs.B[pattern][rot], /*isAdaptive=*/true);
                             } break;

                    case 3 : {   // Corner Transition Patch (9 CVs)
                                 unsigned rot = f->_adaptiveFlags.brots;
                                 iptrs.C[pattern][rot] = getOneRing(f, 9, remapRegularCorner, iptrs.C[pattern][rot]);
                                 pptrs.C[pattern][rot] = computePatchParam(f, pptrs.C[pattern][rot]);
                                 fptrs.C[pattern][rot] = computeFVarData(f, fvarwidth, fptrs.C[pattern][rot], /*isAdaptive=*/true);
                             } break;
                }
            } else
                // No transition Gregory patches
                assert(false);
        }
    }

    // Build Gregory patches vertex valence indices table
    if ((_patchCtr.G > 0) or (_patchCtr.GB > 0)) {

        // MAX_VALENCE is a property of hardware shaders and needs to be matched in OSD
        const int perVertexValenceSize = 2*maxvalence + 1;

        const int nverts = getMesh()->GetNumVertices();

        FarPatchTables::VertexValenceTable & table = result->_vertexValenceTable;
        table.resize(nverts * perVertexValenceSize);

        class GatherNeighborsOperator : public HbrVertexOperator<T> {
        public:
            HbrVertex<T> * center;
            FarPatchTables::VertexValenceTable & table;
            int offset, valence;
            std::vector<int> const & remap;

            GatherNeighborsOperator(FarPatchTables::VertexValenceTable & itable, int ioffset, HbrVertex<T> * v, std::vector<int> const & iremap) :
                center(v), table(itable), offset(ioffset), valence(0), remap(iremap) { }

            ~GatherNeighborsOperator() { }

            // Operator iterates over neighbor vertices of v and accumulates
            // pairs of indices the neighbor and diagonal vertices
            //
            //          Regular case
            //                                           Boundary case
            //      o ------- o      D3 o
            //   D0        N0 |         |
            //                |         |             o ------- o      D2 o
            //                |         |          D0        N0 |         |
            //                |         |                       |         |
            //      o ------- o ------- o                       |         |
            //   N1 |       V |      N3                         |         |
            //      |         |                       o ------- o ------- o
            //      |         |                    N1          V       N2
            //      |         |
            //      o         o ------- o
            //   D1         N2        D2
            //
            virtual void operator() (HbrVertex<T> &v) {

                table[offset++] = remap[v.GetID()];

                HbrVertex<T> * diagonal=&v;

                HbrHalfedge<T> * e = center->GetEdge(&v);
                if ( e ) {
                    // If v is on a boundary, there may not be a diagonal vertex
                    diagonal = e->GetNext()->GetDestVertex();
                }
                //else {
                //    diagonal = v.GetQEONext( center );
                //}

                table[offset++] = remap[diagonal->GetID()];

                ++valence;
            }
        };

        for (int i=0; i<nverts; ++i) {
            HbrVertex<T> * v = getMesh()->GetVertex(i);

            int outputVertexID = _remapTable[v->GetID()];
            int offset = outputVertexID * perVertexValenceSize;

            // feature adaptive refinement can generate un-connected face-vertices
            // that have a valence of 0
            if (not v->IsConnected()) {
                //assert( v->GetParentFace() );
                table[offset] = 0;
                continue;
            }

            // "offset+1" : the first table entry is the vertex valence, which
            // is gathered by the operator (see note below)
            GatherNeighborsOperator op( table, offset+1, v, _remapTable );
            v->ApplyOperatorSurroundingVertices( op );

            // Valence sign bit used to mark boundary vertices
            table[offset] = v->OnBoundary() ? -op.valence : op.valence;

            // Note : some topologies can cause v to be singular at certain
            // levels of adaptive refinement, which prevents us from using
            // the GetValence() function. Fortunately, the GatherNeighbors
            // operator above just performed a similar traversal, so it is
            // very convenient to use it to accumulate the actionable valence.
        }
    } else {
        result->_vertexValenceTable.clear();
    }

    return result;
}

// The One Ring vertices to rule them all !
template <class T> unsigned int *
FarPatchTablesFactory<T>::getOneRing(HbrFace<T> const * f,
    int ringsize, unsigned int const * remap, unsigned int * result) const {

    assert( f and f->GetNumVertices()==4 and ringsize >=4 );

    int idx=0;

    for (unsigned char i=0; i<4; ++i) {
        result[remap[idx++ % ringsize]] =
            _remapTable[f->GetVertex( (i+f->_adaptiveFlags.rots)%4 )->GetID()];
    }

    if (ringsize==16) {

        // Regular case
        //
        //       |      |      |      |
        //       | 4    | 15   | 14   | 13
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       | 5    | 0    | 3    | 12
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       | 6    | 1    | 2    | 11
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       | 7    | 8    | 9    | 10
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       |      |      |      |

        for (int i=0; i<4; ++i) {
            int rot = i+f->_adaptiveFlags.rots;
            HbrVertex<T> * v0 = f->GetVertex( rot % 4 ),
                         * v1 = f->GetVertex( (rot+1) % 4 );

            HbrHalfedge<T> * e = v0->GetNextEdge( v0->GetNextEdge( v0->GetEdge(v1) ) );

            for (int j=0; j<3; ++j) {
                e = e->GetNext();
                result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];
            }
        }

        result += 16;

    } else if (ringsize==12) {

        // Boundary case
        //
        //         4      0      3      5
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       | 11   | 1    | 2    | 6
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       | 10   | 9    | 8    | 7
        //  ---- o ---- o ---- o ---- o ----
        //       |      |      |      |
        //       |      |      |      |

        HbrVertex<T> * v[4];
        for (int i=0; i<4; ++i)
            v[i] = f->GetVertex( (i+f->_adaptiveFlags.rots)%4 );

        HbrHalfedge<T> * e;

        e = v[0]->GetIncidentEdge()->GetPrev()->GetOpposite()->GetPrev();
        result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];

        e = v[1]->GetIncidentEdge();
        result[remap[idx++ % ringsize]] = _remapTable[e->GetDestVertex()->GetID()];

        e = v[2]->GetNextEdge( v[2]->GetEdge(v[1]) );
        for (int i=0; i<3; ++i) {
            e = e->GetNext();
            result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];
        }

        e = v[3]->GetNextEdge( v[3]->GetEdge(v[2]) );
        for (int i=0; i<3; ++i) {
            e = e->GetNext();
            result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];
        }

        result += 12;

    } else if (ringsize==9) {

        // Corner case
        //
        //     0      1      4
        //   o ---- o ---- o ----
        //   |      |      |
        //   | 3    | 2    | 5
        //   o ---- o ---- o ----
        //   |      |      |
        //   | 8    | 7    | 6
        //   o ---- o ---- o ----
        //   |      |      |
        //   |      |      |

        HbrVertex<T> * v0 = f->GetVertex( (0+f->_adaptiveFlags.rots)%4 ),
                     * v2 = f->GetVertex( (2+f->_adaptiveFlags.rots)%4 ),
                     * v3 = f->GetVertex( (3+f->_adaptiveFlags.rots)%4 );

        HbrHalfedge<T> * e;

        e = v0->GetIncidentEdge()->GetPrev()->GetOpposite()->GetPrev();
        result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];

        e = v2->GetIncidentEdge();
        result[remap[idx++ % ringsize]] = _remapTable[e->GetDestVertex()->GetID()];

        e = v3->GetNextEdge( v3->GetEdge(v2) );
        for (int i=0; i<3; ++i) {
            e = e->GetNext();
            result[remap[idx++ % ringsize]] = _remapTable[e->GetOrgVertex()->GetID()];
        }

        result += 9;

    }
    assert(idx==ringsize);
    return result;
}

// Populate the quad-offsets table used by Gregory patches
template <class T> void
FarPatchTablesFactory<T>::getQuadOffsets(HbrFace<T> const * f, unsigned int * result) {

    assert(result and f and f->GetNumVertices()==4);

    // Builds a table of value pairs for each vertex of the patch.
    //
    //            o
    //         N0 |
    //            |
    //            |
    //   o ------ o ------ o
    // N1       V | .... M3
    //            | .......
    //            | .......
    //            o .......
    //          N2
    //
    // [...] [N2 - N3] [...]
    //
    // Each value pair is composed of 2 index values in range [0-4[ pointing
    // to the 2 neighbor vertices to the vertex that belong to the Gregory patch.
    // Neighbor ordering is valence counter-clockwise and must match the winding
    // used to build the vertexValenceTable.
    //

    class GatherOffsetsOperator : public HbrVertexOperator<T> {
    public:
        HbrVertex<T> ** verts; int offsets[2]; int index; int count;

        GatherOffsetsOperator(HbrVertex<T> ** iverts) : verts(iverts) { }

        ~GatherOffsetsOperator() { }

        void reset() {
            index=count=offsets[0]=offsets[1]=0;
        }

        virtual void operator() (HbrVertex<T> &v) {
             // Resolve which 2 neighbor vertices of v belong to the Gregory patch
             for (unsigned char i=0; i<4; ++i)
                if (&v==verts[i]) {
                    assert(count<3);
                    offsets[count++]=index;
                    break;
                }
            ++index;
        }
    };

    // 4 central CVs of the Gregory patch
    HbrVertex<T> * fvs[4] = { f->GetVertex(0),
                              f->GetVertex(1),
                              f->GetVertex(2),
                              f->GetVertex(3) };


    // Hbr vertex operator that iterates over neighbor vertices
    GatherOffsetsOperator op( fvs );

    for (unsigned char i=0; i<4; ++i) {

        op.reset();

        fvs[i]->ApplyOperatorSurroundingVertices( op );

        if (op.offsets[1] - op.offsets[0] != 1)
            std::swap(op.offsets[0], op.offsets[1]);

        // Pack the 2 indices in 16 bits
        result[i] = (op.offsets[0] | (op.offsets[1] << 8));
    }
}

// Computes per-face or per-patch local ptex texture coordinates.
template <class T> FarPatchParam *
FarPatchTablesFactory<T>::computePatchParam(HbrFace<T> const * f, FarPatchParam *coord) {

    unsigned short u, v, ofs = 1;
    unsigned char depth;
    bool nonquad = false;

    if (coord == NULL) return NULL;

    // save the rotation state of the coarse face
    unsigned char rots = (unsigned char)f->_adaptiveFlags.rots;

    // track upwards towards coarse parent face, accumulating u,v indices
    HbrFace<T> const * p = f->GetParent();
    for ( u=v=depth=0;  p!=NULL; depth++ ) {

        int nverts = p->GetNumVertices();
        if ( nverts != 4 ) {           // non-quad coarse face : stop accumulating offsets
            nonquad = true;            // set non-quad bit
            break;
        }

        for (unsigned char i=0; i<nverts; ++i) {
            if ( p->GetChild( i )==f ) {
                switch ( i ) {
                    case 0 :                     break;
                    case 1 : { u+=ofs;         } break;
                    case 2 : { u+=ofs; v+=ofs; } break;
                    case 3 : {         v+=ofs; } break;
                }
                break;
            }
        }
        ofs = (unsigned short)(ofs << 1);
        f = p;
        p = f->GetParent();
    }

    coord->Set( f->GetPtexIndex(), u, v, rots, depth, nonquad );

    return ++coord;
}

// Populates the face-varying data buffer 'coord' for the given face
template <class T> float *
FarPatchTablesFactory<T>::computeFVarData(
    HbrFace<T> const *f, const int width, float *coord, bool isAdaptive) {

    if (coord == NULL) return NULL;

    if (isAdaptive) {

        int rots = f->_adaptiveFlags.rots;
        int nverts = f->GetNumVertices();
        assert(nverts==4);

        for ( int j=0; j < nverts; ++j ) {

            HbrVertex<T> *v      = f->GetVertex((j+rots)%4);
            float        *fvdata = v->GetFVarData(f).GetData(0);

            for ( int k=0; k<width; ++k ) {
                (*coord++) = fvdata[k];
            }
        }

    } else {

        // for each face vertex copy face-varying data into coord pointer
        int nverts = f->GetNumVertices();
        for ( int j=0; j < nverts; ++j ) {

            HbrVertex<T> *v      = f->GetVertex(j);
            float        *fvdata = v->GetFVarData(f).GetData(0);

            for ( int k=0; k<width; ++k ) {
                (*coord++) = fvdata[k];
            }
        }
    }

    // pass back pointer to next destination
    return coord;
}

// splicing functions
template <typename V, typename IT> static IT
copyWithOffset(IT dst_iterator, V const &src, int start, int count, int offset) {
    return std::transform(src.begin()+start, src.begin()+start+count, dst_iterator,
                          std::bind2nd(std::plus<typename V::value_type>(), offset));
}

template <typename V, typename IT> static IT
copyWithOffsetVertexValence(IT dst_iterator, V const &src, int srcMaxValence, int dstMaxValence, int offset) {
    for (typename V::const_iterator it = src.begin(); it != src.end(); ) {
        int valence = *it++;
        *dst_iterator++ = valence;
        valence = abs(valence);
        for (int i = 0; i < 2*dstMaxValence; ++i) {
            if (i < 2*srcMaxValence) {
                *dst_iterator++ = (i < 2*valence) ? *it + offset : 0;
                ++it;
            } else {
                *dst_iterator++ = 0;
            }
        }
    }
    return dst_iterator;
}

template <class T> static FarPatchTables::PTable::iterator
splicePatch(FarPatchTables::Descriptor desc,
            std::vector<FarMesh<T> const *> const &meshes,
            FarPatchTables::PatchArrayVector &result,
            std::vector<FarPatchTables::PatchArrayVector> *multiArrayResult,
            FarPatchTables::PTable::iterator dstIndexIt,
            int *voffset, int *poffset, int *qoffset,
            std::vector<int> const &vertexOffsets) {

    for (size_t i = 0; i < meshes.size(); ++i) {
        FarPatchTables const *patchTables = meshes[i]->GetPatchTables();
        FarPatchTables::PatchArray const *srcPatchArray = patchTables->GetPatchArray(desc);
        if (not srcPatchArray) continue;

        // create new patcharray with offset
        int vindex = srcPatchArray->GetVertIndex();
        int npatch = srcPatchArray->GetNumPatches();
        int nvertex = npatch * desc.GetNumControlVertices();

        FarPatchTables::PatchArray patchArray(desc,
                                              *voffset,
                                              *poffset,
                                              npatch,
                                              *qoffset);
        // append patch array
        result.push_back(patchArray);

        // also store into multiPatchArrays, will be used for partial drawing
        // XXX: can be stored as indices. revisit here later
        if (multiArrayResult) {
            (*multiArrayResult)[i].push_back(patchArray);
        }

        // increment offset
        *voffset += nvertex;
        *poffset += npatch;
        *qoffset += (desc.GetType() == FarPatchTables::GREGORY ||
                     desc.GetType() == FarPatchTables::GREGORY_BOUNDARY) ? npatch * 4 : 0;

        // copy index arrays [vindex, vindex+nvertex]
        dstIndexIt = copyWithOffset(dstIndexIt,
                                    patchTables->GetPatchTable(),
                                    vindex,
                                    nvertex,
                                    vertexOffsets[i]);
    }
    return dstIndexIt;
}

template <class T> FarPatchTables *
FarPatchTablesFactory<T>::Splice(FarMeshVector const &meshes,
                                 MultiPatchArrayVector *multiPatchArrays) {

    int totalQuadOffset0 = 0;
    int totalQuadOffset1 = 0;
    int totalFVarData = 0;
    int fvarWidth = 0;

    std::vector<int> vertexOffsets;
    std::vector<int> gregoryQuadOffsets;
    std::vector<int> numGregoryPatches;
    int vertexOffset = 0;
    int maxValence = 0;
    int numTotalIndices = 0;

    //result->_patchCounts.reserve(meshes.size());
    //FarPatchCount totalCount;
    typedef FarPatchTables::Descriptor Descriptor;

    // note: see FarPatchTablesFactory<T>::Create
    // feature adaptive refinement can generate un-connected face-vertices
    // that have a valence of 0. The spliced vertex valence tables
    // needs to be resized including such un-connected face-vertices.
    int numVerticesInVertexValence = 0;

    // count how many patches exist on each mesh
    for (size_t i = 0; i < meshes.size(); ++i) {
        const FarPatchTables *ptables = meshes[i]->GetPatchTables();
        assert(ptables);

        vertexOffsets.push_back(vertexOffset);
        vertexOffset += meshes[i]->GetNumVertices();

        // need to align maxvalence with the highest value
        maxValence = std::max(maxValence, ptables->_maxValence);

        FarPatchTables::PatchArray const *gregory =
            ptables->GetPatchArray(Descriptor(FarPatchTables::GREGORY,
                                              FarPatchTables::NON_TRANSITION, /*rot*/ 0));
        FarPatchTables::PatchArray const *gregoryBoundary =
            ptables->GetPatchArray(Descriptor(FarPatchTables::GREGORY_BOUNDARY,
                                              FarPatchTables::NON_TRANSITION, /*rot*/ 0));

        int nGregory = gregory ? gregory->GetNumPatches() : 0;
        int nGregoryBoundary = gregoryBoundary ? gregoryBoundary->GetNumPatches() : 0;
        totalQuadOffset0 += nGregory * 4;
        totalQuadOffset1 += nGregoryBoundary * 4;
        numGregoryPatches.push_back(nGregory);
        gregoryQuadOffsets.push_back(totalQuadOffset0);

        totalFVarData += (int)ptables->GetFVarData()._data.size();
        numTotalIndices += ptables->GetNumControlVertices();

        // note: some prims may not have vertex valence table, but still need a space
        // in order to fill following prim's data at appropriate location.
        numVerticesInVertexValence += ptables->_vertexValenceTable.empty()
            ? (int)meshes[i]->GetNumVertices()
            : (int)ptables->_vertexValenceTable.size()/(2*ptables->_maxValence+1);

        // fvarWidth has to be same for all meshes.
        fvarWidth = meshes[i]->GetPatchTables()->GetFVarData().GetFVarWidth();
    }

    FarPatchTables *result = new FarPatchTables(maxValence);

    // Allocate full patches
    result->_patches.resize(numTotalIndices);

    // Allocate vertex valence table, quad offset table
    if (totalQuadOffset0 + totalQuadOffset1 > 0) {
        result->_vertexValenceTable.resize((2*maxValence+1) * numVerticesInVertexValence);
        result->_quadOffsetTable.resize(totalQuadOffset0 + totalQuadOffset1);
    }

    // Allocate fvardata table
    result->_fvarData._data.resize(totalFVarData);

    // splice tables
    // assuming input farmeshes have dense patchtables

    if (multiPatchArrays)
        multiPatchArrays->resize(meshes.size());

    int voffset = 0, poffset = 0, qoffset = 0;
    FarPatchTables::PTable::iterator dstIndexIt = result->_patches.begin();

    // splice patches : iterate over all descriptors, including points, lines, quads, etc.
    for (Descriptor::iterator it=Descriptor::begin(Descriptor::ANY); it!=Descriptor::end(); ++it) {
        dstIndexIt = splicePatch(*it,
                                 meshes,
                                 result->_patchArrays,
                                 multiPatchArrays,
                                 dstIndexIt,
                                 &voffset,
                                 &poffset,
                                 &qoffset,
                                 vertexOffsets);
    }

    // merge vertexvalence and quadoffset tables
    FarPatchTables::QuadOffsetTable::iterator Q0_IT = result->_quadOffsetTable.begin();
    FarPatchTables::QuadOffsetTable::iterator Q1_IT = Q0_IT + totalQuadOffset0;

    FarPatchTables::VertexValenceTable::iterator VV_IT = result->_vertexValenceTable.begin();
    for (size_t i = 0; i < meshes.size(); ++i) {
        const FarPatchTables *ptables = meshes[i]->GetPatchTables();

        // merge vertex valence
        // note: some prims may not have vertex valence table, but still need a space
        // in order to fill following prim's data at appropriate location.
        copyWithOffsetVertexValence(VV_IT,
                                    ptables->_vertexValenceTable,
                                    ptables->_maxValence,
                                    maxValence,
                                    vertexOffsets[i]);

        VV_IT += meshes[i]->GetNumVertices() * (2 * maxValence + 1);

        // merge quad offsets
        int nGregoryQuads = numGregoryPatches[i] * 4;
        if (nGregoryQuads > 0) {
            Q0_IT = std::copy(ptables->_quadOffsetTable.begin(),
                              ptables->_quadOffsetTable.begin()+nGregoryQuads,
                              Q0_IT);
        }
        if (nGregoryQuads < (int)ptables->_quadOffsetTable.size()) {
            Q1_IT = std::copy(ptables->_quadOffsetTable.begin()+nGregoryQuads,
                              ptables->_quadOffsetTable.end(),
                              Q1_IT);
        }
    }

    // merge ptexCoord table
    for (FarPatchTables::Descriptor::iterator it =
        FarPatchTables::Descriptor::begin(FarPatchTables::Descriptor::ANY);
            it != FarPatchTables::Descriptor::end(); ++it) {

        int ptexFaceOffset = 0;
        for (size_t i = 0; i < meshes.size(); ++i) {
            FarPatchTables const *ptables = meshes[i]->GetPatchTables();
            FarPatchTables::PatchArray const *parray = ptables->GetPatchArray(*it);
            if (parray) {
                copyWithPtexFaceOffset(std::back_inserter(result->_paramTable),
                                       ptables->_paramTable,
                                       parray->GetPatchIndex(),
                                       parray->GetNumPatches(), ptexFaceOffset);
            }
            ptexFaceOffset += ptables->GetNumPtexFaces();
        }
    }

    // count total num ptex faces
    int  numPtexFaces = 0;
    for (size_t i = 0; i < meshes.size(); ++i) {
        numPtexFaces += meshes[i]->GetPatchTables()->GetNumPtexFaces();
    }
    result->_numPtexFaces = numPtexFaces;

    // merge fvardata table
    if (fvarWidth > 0) {

        std::vector<float>::iterator FV_IT = result->_fvarData._data.begin();

        for (FarPatchTables::Descriptor::iterator it =
            FarPatchTables::Descriptor::begin(FarPatchTables::Descriptor::ANY);
                it != FarPatchTables::Descriptor::end(); ++it) {

            for (size_t i = 0; i < meshes.size(); ++i) {

                FarPatchTables const *ptables = meshes[i]->GetPatchTables();
                FarPatchTables::PatchArray const *parray = ptables->GetPatchArray(*it);
                FarSubdivisionTables::Scheme scheme = meshes[i]->GetSubdivisionTables()->GetScheme();

                if (parray) {

                    int nv = (scheme == FarSubdivisionTables::LOOP) ? 3 : 4;
                    int width = ptables->GetFVarData().GetFVarWidth() * nv; // for each quads or tris

                    std::vector<float>::const_iterator begin =
                        ptables->_fvarData._data.begin() + parray->GetPatchIndex() * width;

                    std::vector<float>::const_iterator end =
                        begin + parray->GetNumPatches() * width;

                    FV_IT = std::copy(begin, end, FV_IT);
                }
            }
        }

        // set fvarwidth
        result->_fvarData._fvarWidth = fvarWidth;
    }

    return result;
}

template <class T> void
FarPatchTablesFactory<T>::RemapVertices( FarPatchTables * patchTables,
    VertexPermutation const& vertexPermutation )
{
    // Remap the patch control vertex table.
    FarPatchTables::PTable& patches = patchTables->_patches;
    for (FarPatchTables::PTable::iterator i = patches.begin();
        i != patches.end(); ++i)
    {
        unsigned int& vertex = *i;
        VertexPermutation::const_iterator iterator =
            vertexPermutation.find(vertex);
        if (iterator != vertexPermutation.end())
            vertex = iterator->second;
    }

    // Remap the vertex valence table.
    FarPatchTables::VertexValenceTable& vertexValenceTable =
        patchTables->_vertexValenceTable;
    if (!vertexValenceTable.empty()) {
        int maxValence = patchTables->GetMaxValence();
        for (int i = 0; i < (int)vertexValenceTable.size(); i += maxValence) {
            int vertexValence = vertexValenceTable[i];
            for (int j = 0; j < 2 * vertexValence; ++j) {
                int& vertex = vertexValenceTable[i + j + 1];
                VertexPermutation::const_iterator iterator =
                    vertexPermutation.find(vertex);
                if (iterator != vertexPermutation.end())
                    vertex = iterator->second;
            }
        }
    }
}

template <class T> void
FarPatchTablesFactory<T>::ShiftVertices( FarPatchTables * patchTables,
    FarKernelBatch const &kernelBatch, int numVertices )
{
    unsigned int insertVertex = kernelBatch.GetVertexOffset() +
        kernelBatch.GetEnd() - numVertices;

    // Remap the patch control vertex table.
    FarPatchTables::PTable& patchTable = patchTables->_patches;
    for (FarPatchTables::PTable::iterator i = patchTable.begin();
        i != patchTable.end(); ++i)
    {
        unsigned int& vertex = *i;
        if (vertex >= insertVertex)
            vertex += numVertices;
    }
}

template <class T> void
FarPatchTablesFactory<T>::SplitVertices( FarPatchTables * patchTables,
    SplitTable const &splitTable )
{
    FarPatchTables::PTable& patchTable = patchTables->_patches;
    assert(splitTable.size() == patchTable.size());

    for (int i = 0; i < (int)patchTable.size(); ++i) {
        patchTable[i] += splitTable[i];
    }
}

} // end namespace OPENSUBDIV_VERSION
using namespace OPENSUBDIV_VERSION;

} // end namespace OpenSubdiv

#endif /* FAR_PATCH_TABLES_FACTORY_H */
