//
//   Copyright 2013 Pixar
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#ifndef FAR_GREGORY_BASIS_H
#define FAR_GREGORY_BASIS_H

#include "../far/patchTablesFactory.h"
#include "../far/protoStencil.h"
#include "../vtr/level.h"

namespace OpenSubdiv {
namespace OPENSUBDIV_VERSION {

namespace Far {

class TopologyRefiner;

/// \brief Container for gregory basis stencils
///
class GregoryBasis {

public:

    /// \brief Updates point values based on the control values
    ///
    /// \note The destination buffers are assumed to have allocated at least
    ///       \c GetNumStencils() elements.
    ///
    /// @param controlValues  Buffer with primvar data for the control vertices
    ///
    /// @param values         Destination buffer for the interpolated primvar
    ///                       data
    ///
    template <class T, class U>
    void Evaluate(T const & controlValues, U values[20]) const {

        Index const * indices = &_indices.at(0);
        float const * weights = &_weights.at(0);

        for (int i=0; i<20; ++i) {
            values[i].Clear();
            for (int j=0; j<_sizes[i]; ++j, ++indices, ++weights) {
                values[i].AddWithWeight(controlValues[*indices], *weights);
            }
        }
    }

private:

    friend class GregoryBasisFactory;

    int _sizes[20],
        _offsets[20];

    std::vector<Index> _indices;
    std::vector<float> _weights;
};



/// \brief A specialized factory to gather Gregory basis control vertices
///
class GregoryBasisFactory : public PatchTablesFactory::EndPatchFactory {

public:

    //
    // Single patch GregoryBasis basis factory
    //

    /// \brief Instantiates a GregoryBasis from a TopologyRefiner that has been
    ///        refined adaptively for a given face.
    ///
    /// @param refiner     The TopologyRefiner containing the topology
    ///
    /// @param faceIndex   The index of the face (level is assumed to be MaxLevel)
    ///
    /// @param fvarChannel Index of face-varying channel topology (default -1)
    ///
    static GregoryBasis const * Create(TopologyRefiner const & refiner,
        Index faceIndex, int fvarChannel=-1);

    /// \brief Returns the maximum valence of a vertex in the mesh that the
    ///        Gregory patches can handle
    static int GetMaxValence();

public:

    ///
    /// Multi-patch Gregory stencils factory
    ///

    // XXXX need to add support for face-varying channel stencils

    /// \brief This factory accumulates vertex Gregory patch basis
    ///
    /// @param refiner                TopologyRefiner from which to generate patches
    ///
    /// @param shareBoundaryVertices  Use same boundary vertices for neighboring
    ///                               patches. It reduces the number of stencils
    ///                               to be used.
    ///
    GregoryBasisFactory(TopologyRefiner const & refiner,
                        bool shareBoundaryVertices=true);

    /// \brief Returns a patch type for \a patchTag generated by this factory.
    ///
    /// @param patchTag    identified tag information for the patch
    ///
    virtual PatchDescriptor::Type GetPatchType(
        PatchTablesFactory::PatchFaceTag const &patchTag) const;

    /// \brief Returns an end patch vertex indices for \a faceIndex.
    ///
    /// @param level            vtr refinement level
    ///
    /// @param faceIndex        vtr faceIndex at the level
    ///
    /// @param levelPatchTags   Array of patchTags for all faces in the level
    ///
    /// @param levelVertOffset  relative offset of patch vertex indices
    ///
    virtual ConstIndexArray GetTopology(
        Vtr::Level const& level, Index faceIndex,
        PatchTablesFactory::PatchFaceTag const * levelPatchTags,
        int levelVertOffset);

    /// \brief Returns the face index in vtr level for the given \a patchIndex.
    Index GetFaceIndex(Index patchIndex) const { return basisIndices[patchIndex]; }

    /// \brief Returns the number of gregory basis patches generated.
    ///
    int GetNumGregoryBasisPatches() const { return numGregoryBasisPatches; }

    /// \brief Returns the number of gregory basis vertices generated.
    ///
    int GetNumGregoryBasisVertices() const { return numGregoryBasisVertices; }

    /// After all the gregory basisi vertices have been collected, factorize
    /// their stencils with given stencil table and create new stencil table.
    ///
    /// @param baseStencils  source stencil table
    ///
    /// @param append        if true, returns concatinated stencil table which
    ///                      also includes source stencil table at the front.
    ///
    /// @param permute       index permutation table (optional)
    ///
    StencilTables const * CreateVertexStencilTables(
        StencilTables const *baseStencils,
        bool append,
        int const permute[20]=0) {
        return createStencilTables(
            baseStencils, append, _vertexStencils, permute);
    }
    StencilTables const * CreateVaryingStencilTables(
        StencilTables const *baseStencils,
        bool append,
        int const permute[20]=0) {
        return createStencilTables(
            baseStencils, append, _varyingStencils, permute);
    }

private:

    /// Creates a basis for the vertices specified in mask on the face and
    /// accumates it
    bool addPatchBasis(Index faceIndex, bool newVerticesMask[4][5]);
    
    // limit valence of 30 because we use a pre-computed closed-form 'ef' table
    // XXXtakahito: revisit here to determine appropriate size
    //              or remove fixed size limit and use Sdc mask
    static int getNumMaxElements(int maxValence) {
        return (16 + maxValence);
    }
    static const int MAX_VALENCE = (30*2);
    static const int MAX_ELEMS = (16 + MAX_VALENCE);

    //
    // Basis point
    //
    // Implements arithmetic operators to manipulate the influence of the
    // 1-ring control vertices supporting the patch basis
    //
    class Point {

    public:

        Point() : _size(0) { }

        Point(Index idx, float weight = 1.0f) {
            _size = 1;
            _indices[0] = idx;
            _weights[0] = weight;
        }

        Point(Point const & other) {
            *this = other;
        }

        int GetSize() const {
            return _size;
        }

        Index const * GetIndices() const {
            return _indices;
        }

        float const * GetWeights() const {
            return _weights;
        }

        Point & operator = (Point const & other) {
            _size = other._size;
            memcpy(_indices, other._indices, other._size*sizeof(Index));
            memcpy(_weights, other._weights, other._size*sizeof(float));
            return *this;
        }

        Point & operator += (Point const & other) {
            for (int i=0; i<other._size; ++i) {
                Index idx = findIndex(other._indices[i]);
                _weights[idx] += other._weights[i];
            }
            return *this;
        }

        Point & operator -= (Point const & other) {
            for (int i=0; i<other._size; ++i) {
                Index idx = findIndex(other._indices[i]);
                _weights[idx] -= other._weights[i];
            }
            return *this;
        }

        Point & operator *= (float f) {
            for (int i=0; i<_size; ++i) {
                _weights[i] *= f;
            }
            return *this;
        }

        Point & operator /= (float f) {
            return (*this)*=(1.0f/f);
        }
        
        friend Point operator * (Point const & src, float f) {
            Point p( src ); return p*=f;
        }
        
        friend Point operator / (Point const & src, float f) {
            Point p( src ); return p*= (1.0f/f);
        }
        
        Point operator + (Point const & other) {
            Point p(*this); return p+=other;
        }

        Point operator - (Point const & other) {
            Point p(*this); return p-=other;
        }

        void OffsetIndices(Index offset) {
            for (int i=0; i<_size; ++i) {
                _indices[i] += offset;
            }
        }

        void Copy(int ** size, Index ** indices, float ** weights) const;

    private:

        int findIndex(Index idx) {
            for (int i=0; i<_size; ++i) {
                if (_indices[i]==idx) {
                    return i;
                }
            }
            _indices[_size]=idx;
            _weights[_size]=0.0f;
            ++_size;
            return _size-1;
        }
        
        int _size;
        // XXXX this would really be better with VLA where we only allocate
        // space based on the max vertex valence in the mesh, not the
        // absolute maximum supported by the closed-form tangents table.
        Index _indices[MAX_ELEMS];
        float _weights[MAX_ELEMS];
    };

    struct ProtoBasis;
    
    static void factorizeBasisVertex(
        StencilTables const * stencils,
        GregoryBasisFactory::Point const & p, ProtoStencil dst);

    StencilTables const * createStencilTables(
        StencilTables const *baseStencils,
        bool append,
        std::vector<Point> const &gregoryStencils,
        int const permute[20]);

    std::vector<Point> _vertexStencils;
    std::vector<Point> _varyingStencils;

    TopologyRefiner const & _refiner; // XXXX these should be smart pointers !
    int _maxvalence;
    bool _shareBoundaryVertices;
    
    int numGregoryBasisVertices;
    int numGregoryBasisPatches;
    std::vector<Index> basisIndices;
    std::vector<Index> topology;

};

} // end namespace Far

} // end namespace OPENSUBDIV_VERSION
} // end namespace OpenSubdiv

#endif /* FAR_GREGORY_BASIS_H */
